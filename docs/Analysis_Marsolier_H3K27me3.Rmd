---
    title: "Marsolier et al., H3K27me3 scChIP-seq"
author: "Pacome Prompsy"
date: "22/04/2021"
output: html_document
---
    
    ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ChromSCape)
```

# Analysing H3K27me3 single-cell ChIP-seq of Triple Negative Breast Cancer (TNBC) under treatment 

In this tutorial, we will analyse the dynamics of H3K27me3 in TNBC cell line MDA-MB-468 under treatment to
 a chemotherapy drug, 5-FU [paper](https://www.biorxiv.org/content/10.1101/2021.01.04.423386v1).
There are multiple conditions that each were treated for a different amount of time
with the drug (5-FU) or not (DMSO). 

## Download the count matrices

We first have to download the count matrices of this paper, available at 
GSEXXXXX. Download all the count matrices starting with 'MM468' and finishing by
'_peaks.tsv.gz'. For these counts matrices the reads were counted on peaks obtained
with bulk ChIP-seq experiments.

## Set up directory structure

If you want to save your data to be able to reupload it interarctively on 
ChromSCape without the need to through all the steps, you must set up a 
directory structure recognizable by ChromSCape.

```{r}
# Change this path to the path where you want to create the project
output_directory = "../../../Data/ChromSCape_Data/ChromSCape_3.13_2/"

analysis_name = "Marsolier_H3K27me3"
ref_genome = "hg38"

# Create project folder, so that the analysis will be available on ChromSCape Shiny App.
ChromSCape_directory <- create_project_folder(output_directory,
                                                  analysis_name,
                                                  ref_genome)
```

## Read the data
We next read in the single-cell count matrices and merge them altogether into 
one matrix. 

```{r}
# Change this path to the path where the count matrices were saved
path_to_matrices = "~/Insync/pacome.pr@gmail.com/Google Drive - Shared with me/DEpic_bioinfo/ChemoPersistance/input/scChIPseq/MM468/Count_Matrices/"

files = list.files(path_to_matrices, pattern = "H3K27me3_peaks.tsv.gz",
                   full.names = TRUE)

# Read in each condition - naming the file name
raw_data = ChromSCape::import_scExp(file_paths = files,
                                    remove_pattern = "_H3K27me3_peaks")

datamatrix = raw_data$datamatrix
annot_raw = raw_data$annot_raw

qs::qsave(datamatrix, file = file.path(ChromSCape_directory, "datamatrix.qs"))
qs::qsave(annot_raw, file = file.path(ChromSCape_directory, "annot_raw.qs"))
```


## Filter, normalize and reduce dimension 

We now create want to filter out cells that are too low (artifacts) or too high
(probalby doublets), as well as uninformative features (features not present in
enough cells). We then normalize and reduce the dimensionality of the matrix 
using PCA and UMAP for visualisation.
  
We will keep all the cells with more than 1500 reads,
and remove any cell with higher than the 95th centile of read coverage. As we are
working with pre-defined peaks, we want to keep the high majority of peaks, so 
we keep all of the 9,568 peaks.
  
In this particular cell line, it is known that high genetic re-arrangements 
occur during cell culture. We want to eliminate any source of genetic variability
to focus on the epigenetic variability, therefore removing known Copy Number 
Alterations (CNA) in these cell lines.
  
We use the wrapper function preprocessing_filtering_and_reduction() to run these
steps smoothly.


```{r}
# Download CNA location BED file
# CNA = read.table("https://github.com/vallotlab/ChemoPersistance/blob/master/annotation/MM468_identified_CNA.bed.gz")
CNA = rtracklayer::import(file.path(path_to_matrices,"../../../../annotation/MM468_identified_CNA.bed.gz"))

min_reads_per_cell = 1500
max_quantile_read_per_cell = 95
n_top_features = 10000

scExp = preprocessing_filtering_and_reduction(datamatrix,
                                      annot_raw,
                                      min_reads_per_cell = min_reads_per_cell,
                                      max_quantile_read_per_cell = max_quantile_read_per_cell,
                                      n_top_features = n_top_features,
                                      subsample_n = 2000, # subsample each condition to 2000 cells
                                      ref_genome = ref_genome,
                                      exclude_regions = CNA)

# Save 
prefix = paste(analysis_name,min_reads_per_cell,n_top_features,max_quantile_read_per_cell,"uncorrected",sep="_")
qs::qsave(scExp, file = file.path(ChromSCape_directory, "Filtering_Normalize_Reduce",paste0(prefix,".qs")))

```

## Visualizing cells


Let's vizualise our dataset in the reduced feature space:


```{r, fig.show="hold", out.width="50%"}
# library(gridExtra)
# library(grid)
# p1 = plot_reduced_dim_scExp(scExp, "sample_id","PCA")
# p2 = plot_reduced_dim_scExp(scExp, "total_counts","PCA")
par(mfrow=c(1,2))
plot(reducedDim(scExp,"UMAP")[,1:2], col = alpha(scExp$sample_id_color,0.6), pch = 20, cex = 0.25) 
plot(reducedDim(scExp,"UMAP")[,1:2], col = alpha(scExp$total_counts_color,0.6), pch = 20, cex = 0.25) 
# grid.arrange(p1,p2, nrow=1, ncol=2)
```

## Clustering cells

Before we move on to clustering, we usually want to filter out lowly correlated 
cells, e.g. cells that have more than a "good" pearson correlation score with at least 
1 % of the other cells.  
We can then perform consensus hierarchical clustering testing a number of clusters
ranging from 2 to 8. This allows us to determine what is the best number of 
clusters to group our cells by.


```{r}
# Filter lowly correlated cells
scExp_cf = filter_correlated_cell_scExp(scExp, random_iter = 5,
                                        corr_threshold = 99,
                                        percent_correlation = 1)

runConsensus = FALSE # Memory & time heavy - skipping this part
if(runConsensus){
scExp_cf = consensus_clustering_scExp(scExp_cf, reps = 10,
                                      maxK = 8,
                                      clusterAlg = "hc")

### Choose most robust cluster #####
average_consensus_score = scExp_cf@metadata$icl$clusterConsensus %>% 
    as.data.frame %>% dplyr::group_by(k) %>% summarise(mean = mean(clusterConsensus))
average_consensus_score$diff = 0 
average_consensus_score$diff[2:(maxK-1)] = average_consensus_score$mean[2:(maxK-1)] - average_consensus_score$mean[1:(maxK-2)]
nclust = average_consensus_score$k[which.max(abs(average_consensus_score$diff))-1]

if(!is.null(n_clust)) nclust =n_clust
} else{
  nclust = 6
}

scExp_cf = choose_cluster_scExp(scExp_cf, nclust = nclust, consensus = runConsensus)

data = list("scExp_cf" = scExp_cf)
qs::qsave(data, file = file.path(ChromSCape_directory,"correlation_clustering", paste0(prefix,".qs")))

```
  

Let's now vizualise our cells in the reduced UMAP space :

```{r}
# set cluster colors :
color_df = data.frame(cell_cluster = unique(scExp_cf$cell_cluster),
                      cell_cluster_color =unique(scExp_cf$cell_cluster_color))
color_df$cell_cluster_color = c("#D61111", "#1F68AD", "#439418", "#EBB812")
scExp_cf = colors_scExp(scExp_cf,annotCol =  c("cell_cluster"),
             color_by = "cell_cluster", color_df = color_df)


p1 = plot_reduced_dim_scExp(scExp_cf, "sample_id","UMAP")
p2 = plot_reduced_dim_scExp(scExp_cf, "cell_cluster","UMAP")
grid.arrange(p1,p2, nrow=1, ncol=2)
```


## Differential analysis

Now that we have defined our cluster in an unsupervised manner, we can investigate 
on the regions with different chromatin mark level between the clusters. We run
a non-parametric Wilcoxon rank test to assess if regions have differential chromatin 
mark levels in one cluster against the rest of the cells.

```{r}

scExp_cf = differential_analysis_scExp(scExp_cf,
                            method = "wilcox",
                            de_type = de_type,
                            cdiff.th = 1,
                            qval.th = 0.01)
```

We can vizualise most differential regions in cluster C1 against the rest of cells with a volcano plot:

```{r}
plot_differential_volcano_scExp(scExp_cf, cell_cluster = "C1")
```

And plot a summary of the differential regions :

```{r}
plot_differential_summary_scExp(scExp_cf)
```


## Gene set analysis

Now that we have identified differential regions, we want to understand the biology
behind the different chromating landscapes. H3K27me3 is a repressive histone mark,
shutting down gene expression. Therefore if we are interested in regions available 
for transcription in one epigenetic population, we should look at all the genes in 
regions with lower level of chromatin mark in this population compared to other populations.

```{r}
de_type = "one_vs_rest"
qval.th = 0.01
cdiff.th = 1
scExp_cf = gene_set_enrichment_analysis_scExp(scExp_cf,
                            ref = ref_genome,
                            enrichment_qval = 0.1, 
                            peak_distance = 1000,
                            use_peaks =  F,
                            qval.th = qval.th, 
                            cdiff.th = cdiff.th,
                            )

qs::qsave(scExp_cf,file = file.path(ChromSCape_directory,"Diff_Analysis_Gene_Sets",
                            paste0(prefix,"_",nclust,"_",qval.th,"_",cdiff.th,"_",de_type,".qs")))
```

Let's now observe top gene set associated with a depletion of H3K27me3 in cluster
C4 (composed of 100% Ramos B cells). We can see one pathway related to B cell in the 
genes associated with a depletion of H3K27me3 mark.

```{r}
classes = c("c2_curated","c5_GO","c6_oncogenic","c7_immunologic", "hallmark")
head(scExp_cf@metadata$enr$Underexpressed[[4]])
```


## Conclusion

These script enable users to perform the same analysis as when launching
the application in a browser. This might be useful if users benchmark various
parameters so that the analyses can be run in parallel on a HPC, of simply
if users want to custom their analysis by adding extra step or hacking the functions
to produce high quality plots and so on.
Have fun !
    
    
    