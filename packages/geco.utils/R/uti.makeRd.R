# Rd
# description >> generate Rd files for a given parsed \code{R} file with annotations of functions following the makeRd format, as generated by \link[geco.utils]{geco.getMakeRd}
# argument
# item >>  file >> the given \file{.R} file to parse
# item >> directory >> the directory where the \file{.Rd} file is generated
# item >> verbose >> if \code{TRUE}, it lists the files created. \code{FALSE} by default
# item >> ... >> non-matched further arguments are disregarded
# value >> generate a \file{.Rd} file for a given parsed file
# author >> Eric Letouze
# keyword >> documentation
# end
geco.makeRd = function(file, directory = NULL, verbose = FALSE,
                  ... ){
  if (length(list(...)) > 0)
    warning("non-matched further arguments are disregarded");

  input = readLines(file)
  
  KEYWORD = NULL
  
  if( length(input)> 0 ){
     for (iii in 1:length(input)){
      if (length(unlist(strsplit(input[iii], split = " "))) == 2 & unlist(strsplit(input[iii], split = " "))[2] == "Rd" & unlist(strsplit(input[iii], split = " "))[1] == "#" ){
        Rd = character(0)
        nblines = 1
        #find end
        fend = 0
        jjj = iii
        while (fend == 0){
          jjj = jjj+1
          #if (length(unlist(strsplit(input[jjj], split = " "))) == 2 & unlist(strsplit(input[jjj], split = " "))[2] == "end")
            if (unlist(strsplit(input[jjj], split = " "))[1] == "#" & unlist(strsplit(input[jjj], split = " "))[2] == "end")
            fend = jjj
        }
        #name, alias and title
        fposition = fend+1
        while(input[fposition] == "")
          fposition = fposition+1;
          
        fline = input[fposition]
        fline = gsub(" ", "", fline)
        fname = unlist(strsplit(fline, split = "function\\("))[1]
        fname = gsub("=", "", fname)
        fname = gsub("<-", "", fname)
        Rd[nblines] = paste("\\name{", fname,"}", sep = "")
        nblines = nblines+1
        Rd[nblines] = paste("\\alias{", fname,"}", sep = "")
        nblines = nblines+1
        Rd[nblines] = paste("\\title{", fname,"}", sep = "")
        nblines = nblines+1
        #description
        iii = iii+1
        fdescription = unlist(strsplit(input[iii], split = " >> "))[2]
        Rd[nblines] = paste("\\description{", fdescription,"}", sep = "")
        nblines = nblines+1
        # usage
        zzz = fposition
        fusage = character(0)
        
        ## modif LM 2009-08-03 in order to allow white space in arguments
        while (!("{" %in% unlist(strsplit(input[zzz], split = "")))){
          inpz <- sub("^ *", "", input[zzz]) #inpz <- input[zzz]
          fusage = paste(fusage, paste(unlist(strsplit(inpz, split = "")), sep = "", collapse = ""), sep = "", collpase = "")
          zzz = zzz+1
        }
        fusage = paste(fusage, paste(unlist(strsplit(sub("^ *", "", input[zzz]), split = "")), sep = "", collapse = ""), sep = "", collpase = "")

        fusage <- sub("\\{ *$", "", fusage)  # remove last {
        fusage <- gsub(" *= *","=", fusage) # remove supernumerary white spaces
        fusage <- gsub(" *= *function *","", fusage)
        fusage <- gsub(" *<- *function *","", fusage)

        # manage %
        fusage <- gsub("%", "\\%", fusage, fixed=T)
        
#        while (!("{" %in% unlist(strsplit(input[zzz], split = "")))){
#          fusage = paste(fusage, paste(unlist(strsplit(input[zzz], split = "")), sep = "", collapse = ""), sep = "", collpase = "")
#          zzz = zzz+1
#        }
#        fusage = paste(fusage, paste(unlist(strsplit(input[zzz], split = "")), sep = "", collapse = ""), sep = "", collpase = "")
#        fusage2 = unlist(strsplit(fusage, split = ""))
#        aa = which(fusage2 == " ")
#        if (length(aa) > 0)
#          fusage2 = fusage2[-aa]
#        fusage2 = fusage2[1:(length(fusage2)-1)] # remove last "{"
#        fusage2 = paste(fusage2, sep = "", collapse = "")
#        fusage = fusage2
#        fusage = gsub("=function","", fusage)
#        fusage = gsub("<-function","", fusage)

        ## end modif LM 2009-08-03
        
        
        Rd[nblines] = paste("\\usage{", fusage, "}", sep = "")
        nblines = nblines+1
        # argument, value, author ...
        for (jjj in (iii+1):(fend-1)){
          if (unlist(strsplit(input[jjj], split = " "))[2] == "argument"){
            Rd[nblines] = "\\arguments{"; 
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "item")
            Rd[nblines] = paste("\\item{",unlist(strsplit(input[jjj], split = " >> "))[2],"}{",  unlist(strsplit(input[jjj], split = " >> "))[3], "}", sep = "");
          if (unlist(strsplit(input[jjj], split = " "))[2] == "details"){
            if (unlist(strsplit(input[jjj], split = " >> "))[2] != "...")
              Rd[nblines] = paste("\\details{",unlist(strsplit(input[jjj], split = " >> "))[2] ,"}", sep = "")
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "value"){
            if (unlist(strsplit(input[jjj-1], split = " "))[2] == "item"){
              Rd[nblines] = "}"
              nblines = nblines+1
            }
            Rd[nblines] = paste("\\value{", unlist(strsplit(input[jjj], split = " >> "))[2] , sep = "")
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "references"){
            if (unlist(strsplit(input[jjj], split = " >> "))[2] != "...")
              Rd[nblines] = paste("\\references{",unlist(strsplit(input[jjj], split = " >> "))[2] ,"}", sep = "")
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "author"){
            Rd[nblines] = "}"
            nblines = nblines+1
            Rd[nblines] = paste("\\author{",unlist(strsplit(input[jjj], split = " >> "))[2] ,"}", sep = "")
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "seealso"){
              if (unlist(strsplit(input[jjj], split = " >> "))[2] != "...")
            Rd[nblines] = paste("\\seealso{",unlist(strsplit(input[jjj], split = " >> "))[2] ,"}", sep = "")
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "examples"){
              if (unlist(strsplit(input[jjj], split = " >> "))[2] != "..."){
                if (unlist(strsplit(input[jjj-1], split = " "))[2] == "examples"){
                  Rd[nblines] = unlist(strsplit(input[jjj], split = " >> "))[2]  
                } else {
                  Rd[nblines] = paste("\\examples{",unlist(strsplit(input[jjj], split = " >> "))[2] , sep = "")
                  EXOPENED = TRUE
                }
              if (unlist(strsplit(input[jjj+1], split = " "))[2] != "examples")
                Rd[nblines] = paste(Rd[nblines], "}", sep = " ")
            }
          }
          if (unlist(strsplit(input[jjj], split = " "))[2] == "keyword"){
            KEYWORD = unlist(strsplit(input[jjj], split = " "))[4]
            Rd[nblines] = paste("\\keyword{",KEYWORD,"}", sep = "")
          }
          nblines = nblines+1;
        }
        if (is.null(KEYWORD)){
          Rd[nblines] = "\\keyword{methods}"
          nblines = nblines+1
        }
        
        if (is.null(directory))
          directory = getwd();
        na = which(is.na(Rd))
        if (length(na) > 0)
          Rd = Rd[-na]
        write(Rd, file = file.path(directory,paste(fname, ".Rd", sep = "")))
        if (verbose)
          print(file.path(directory,paste(fname, ".Rd", sep = "")));
        iii = zzz
      }
    }
  }
}

# Rd
# description >> generate a \file{.Rd} for all the CIT packages
# argument
# item >>  pack >> the set of package to parse. \code{NULL} by default corresponding to all the CIT packages
# item >> directory >> the top directory of the CIT packages
# item >> verbose >> if \code{TRUE}, it lists the files created. \code{FALSE} by default
# value >> generate \file{.Rd} files in the \file{man} directory of each package
# author >> Eric Letouze
# keyword >> documentation
# end
geco.makeRdPackScan = function(pack, directory = NULL, verbose = FALSE){
  if (!missing(pack))
    pack = as.character(substitute(pack));
  
  if (missing(pack))
    pack = CITPACK;

  if (is.null(directory))
    directory = USERDIR;
  
  if (is.null(directory))
    directory = getwd();
  
  for (iii in 1:length(pack)){
    if(verbose) print(toupper(pack[iii]))
    R = file.path(directory, pack[iii],"R")
    MAN = file.path(directory, pack[iii],"man")
    lf = list.files(path = R,pattern = ".R")
    if( length(lf) ){
      for (jjj in 1:length(lf)){
       if(verbose) print(file.path(R, lf[jjj]))
       geco.makeRd(file = file.path(R, lf[jjj]), directory = MAN, verbose = verbose)
      }
    }
  }
}


# Rd
# description >> generate a template in the \emph{makeRd} format to ease the production of \file{.Rd} files
# argument
# item >> fun >> an existing \code{R} function: fill the items in the template argument field 
# item >> author >> a string: fill the template author field
# item >> keyword >> a string: fill the template value field
# item >> description >> a string: fill the template description field 
# item >> value >> a string: fill the template value field 
# value >> return a makeRd template to copy/paste as commentary in \code{R} files. 
# author >> Eric Letouze
# keyword >> methods
# end
geco.getMakeRd = function(fun = NULL, author = NULL, keyword = "methods", description = "required", value = "required"){

  funToPrint = "# Rd\n"
  if (is.null(author))
    author = "fisrtName1 lastName1"
  
  if (!keyword %in% geco.listRKeywords())
    stop("the 'keyword' argument does not match a valid R keyword.")
  funToPrint = paste(funToPrint,"# description >> ", description,"\n", sep = "")
  if(!is.null(fun)){
    ARGS = formalArgs(fun)
    if (length(ARGS) > 0){
      funToPrint = paste(funToPrint,"# argument\n", sep = "")
      for (iii in 1:length(ARGS))
        funToPrint = paste(funToPrint,"# item >> ", ARGS[iii]," >> required\n",sep = "");
    }
  } else {
    funToPrint = paste(funToPrint,"# argument\n", sep = "")
    funToPrint = paste(funToPrint,"# item >> parameter1 >> description for \\code{example1}\n",sep = "")
    funToPrint = paste(funToPrint,"# item >> parameter2 >> description for \\code{example1}\n",sep = "")
    funToPrint = paste(funToPrint,"# item >> ... >> other parameters\n",sep = "")  
  }
  funToPrint = paste(funToPrint,"# value >> ", value,"\n", sep = "")
  funToPrint = paste(funToPrint,"# author >> ", author,"\n", sep = "")
  funToPrint = paste(funToPrint,"# keyword >> ", keyword,"\n", sep = "")
  funToPrint = paste(funToPrint,"# details >> ...","\n", sep = "")
  funToPrint = paste(funToPrint,"# seealso >> ...","\n", sep = "")
  funToPrint = paste(funToPrint,"# references >> ...","\n", sep = "")
  funToPrint = paste(funToPrint,"# examples >> ...","\n", sep = "")
  funToPrint = paste(funToPrint,"# end\n\n", sep = "")
  cat(funToPrint)
}



# Rd
# description >> list the standard R keywords
# value >> return a vector of keywords
# author >> Eric Letouze
# keyword >> methods
# end
geco.listRKeywords = function(){
  input = readLines(file.path(R.home("doc"), "KEYWORDS"))
  KEYWORDS = NULL
  for (iii in 1:length(input)){
    keyword = unlist(strsplit(input[iii], "\t"))
    if (length(keyword) > 2){
      keyword = keyword[2]
      keyword = gsub(" ", "", keyword)
      keyword = gsub("&", "", keyword)
      KEYWORDS = c(KEYWORDS,keyword)
    }
  }
return(KEYWORDS[order(KEYWORDS)])
}

# Rd
# description >> generate a template in the \emph{makeRd} format to ease the production of \file{.Rd} files for internal functions
# argument
# item >> fun >> an existing \code{R} function: fill the items in the template argument field 
# item >> author >> a string: fill the template author field
# value >> return a makeRd template to copy/paste as commentary in \code{R} files. 
# author >> Eric Letouze
# keyword >> methods
# end
geco.getMakeRdInternal = function(fun = NULL, author = NULL){
  geco.getMakeRd(fun = fun, author = author, keyword = "internal", description = "this an internal and uncommented function to not use directly", value = "")
}


